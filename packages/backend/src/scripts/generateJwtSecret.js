#!/usr/bin/env node
import fs from 'fs'
import path from 'path'
import crypto from 'crypto'

// Simple utility to generate a random JWT secret and optionally write to a .env file
// Usage:
//   node src/scripts/generateJwtSecret.js           -> prints secret and export line
//   node src/scripts/generateJwtSecret.js --length 64
//   node src/scripts/generateJwtSecret.js --save .env

const argv = process.argv.slice(2)
const getArg = (name) => {
  const i = argv.indexOf(name)
  if (i === -1) return null
  if (i + 1 < argv.length) return argv[i + 1]
  return true
}

const length = parseInt(getArg('--length')) || 64
const savePath = getArg('--save')

if (!Number.isInteger(length) || length <= 0 || length > 1024) {
  console.error('Length must be a positive integer (<=1024)')
  process.exit(2)
}

const secret = crypto.randomBytes(length).toString('base64')

console.log('# Copy this value to your .env or secret manager')
console.log('JWT_SECRET=' + secret)

if (savePath) {
  const target = String(savePath)
  try {
    const envPath = path.resolve(target)
    let content = ''
    if (fs.existsSync(envPath)) {
      content = fs.readFileSync(envPath, 'utf8')
      const regex = /^JWT_SECRET=.*$/m
      if (regex.test(content)) {
        content = content.replace(regex, `JWT_SECRET=${secret}`)
      } else {
        if (!content.endsWith('\n')) content += '\n'
        content += `JWT_SECRET=${secret}\n`
      }
    } else {
      content = `# Generated by generateJwtSecret.js\nJWT_SECRET=${secret}\n`
    }
    fs.writeFileSync(envPath, content, { encoding: 'utf8', mode: 0o600 })
    console.log(`Saved JWT_SECRET to ${envPath}`)
  } catch (err) {
    console.error('Failed to save .env file:', err.message || err)
    process.exit(1)
  }
}
